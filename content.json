{"meta":{"title":"罐子里的茶","subtitle":"","description":"","author":"罐子里的茶","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2021-11-14T16:59:28.000Z","updated":"2022-03-21T10:36:27.690Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2021-11-23T14:11:13.000Z","updated":"2022-03-21T10:36:27.690Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"工作生活随记，感谢你看到这里。不妨留下言吧，我的朋友。 本站模板源码：Volantis"},{"title":"faqs","date":"2021-11-14T17:00:48.000Z","updated":"2022-03-21T10:36:27.690Z","comments":true,"path":"faqs/index.html","permalink":"http://example.com/faqs/index.html","excerpt":"","text":""},{"title":"contributors","date":"2021-11-14T16:59:46.000Z","updated":"2022-03-21T10:36:27.690Z","comments":true,"path":"contributors/index.html","permalink":"http://example.com/contributors/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-11-19T02:37:07.000Z","updated":"2022-03-21T10:36:27.690Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"「MoreThanCode」Redis 1：数据存储","slug":"Redis(1)数据存储","date":"2022-03-21T10:36:27.689Z","updated":"2022-03-21T10:36:27.689Z","comments":true,"path":"2022/03/21/Redis(1)数据存储/","link":"","permalink":"http://example.com/2022/03/21/Redis(1)%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/","excerpt":"","text":"1 简述​ 使用redis也有一段时间了，这次准备把redis相关的知识点好好汇总一下，大致分为几下几章：数据存储、网络模型、持久化、哨兵主从、集群、分布式消息/队列 ，本篇文章为redis系列的第一篇：数据存储 2 数据类型​ 开始一门新的数据框架当然还是要从基本的东西开始。像刚开始学java从8大基本数据类型开始一样，接触redis当然也要从它的5大基本数据类型(String、hash、list、set、zset)开始，至于扩展的数据类型(bitmap、HyperLogLog、Geo、Stream、RedisTimeSeries)将在后续涉及的文章中再做介绍。redis快的原因最最主要的还是基于内存，下图是来自中关村的内存读取速度测试结果: 可以看到读取速度基本在恐怖的35GB/s+，最新一代m1 max 的mac宣称内存速度更是在400GB/s。当然mac的内存和服务器的内存还有点区别，不在本章讨论范围。下图是我的固态硬盘的读取速度，用了好几年，速度基本在200mb/s+： 如果是机械硬盘，速度更是只有一百多兆/s甚至几十兆/s，跟主流内存的速度至少差了两个量级。 2.1内部数据类型​ 私认为任何一门新技术的最好文档永远是官方文档，这里是redis的中文文档。当我们执行一个简单的字符串存储时例如：set sun moon,redis是这么来存储数据的： ​ dicEntry​ 众所周知redis是一键值对数据库，而每一个键值对就存储在这个dicEntry结构体中。其中key就是这个键值对的“键”,是一个SDS(simple dynamic string 简单动态字符串),下面会有SDS的介绍，val里存着用redisObject包裹的“值”。next则指向下一个键值对，也就是下一个redis对象。 redisObject​ type:用于记录“值”的数据类型，例如我们执行的set sun moon，这里的”moon”的数据类型显然是字符串，所以type中所存储的值为String。 ​ ptr:用于记录“值”，只不过这个值也是存储在一个SDS中。 SDS​ redis是用c语言编写的，但是在redis中字符串定义方式却是将字符串存储在一个结构体里，这个结构体就叫做SDS(simple dynamic string 简单动态字符串)。redis的字符串之所以叫Strings而不是String可能也和这个有关系。SDS一共有三个属性(buf、len、free)。 buf:类型是字节数组，用于存储字符串,在c语言中，以’\\0’表示字符串结尾。在本例中dicEntry中’”sun”，就存储在这里。 len:记录buf数组中的字节长度，且不会包含结尾的’\\0’字符的长度 free:记录buf数组中空余的字节数据 SDS存储与简单的字符串相比有以下几个优点： 1、降低获取字符串长度的时间： 因为SDS讲字符数据的长度信息存储在len里，获取字符串长度的时间复杂度从原来的O(n)降低到O(1)，这样在大批量执行strlen(用于获取字符串长度)命令时,redis也可以快速响应。也可以说SDS是在用空间换时间。 2、避免缓冲区溢出: 假设两个普通的C字符串在内存中的地址是连续的，S1为”sun”,S2为”moon”: ​ 当我们直接对S1进行追加字符串操作时，比如新增一个” redis”（注意空格），则内存中的存储此时会变成这样： ​ 显然原字符串S2的内容会被冲掉，这种情况就叫做缓冲区溢出，那么SDS是如何来避免缓冲区溢出的呢？首先SDS存储”sun”时是这样的： ​ 在我们追加“ redis”****(注意空格)*这个字符串时，显然长度5大于SDS的free长度，所以SDS在存储前会进行扩容*操作，扩容后再拼接，此时的字符串是这样的： ​ 扩容后的len和free是相等的，这也是sds的扩容策略之一。目的是为了降低内存重分配次数。 3、降低内存重分配次数： ​ 对于一个sds，如果需要拼接N次，redis作者显然不会进行N次扩容，因为这样就会涉及N次内存分配，这无疑会影响性能。 ​ 实际上在对一个sds字符串进行拼接时，如果要拼接的字符串长度大于sds的free值，且拼接后的字符串长度小于1MB，那么扩容后的free值将恒等于buf的实际长度，即len值。如果拼接后的buff长度大于1MB，那么free值恒等于1MB也就是2^10(1024 * 1024)字节。上述的sds拼接后buf共占据了 9 + 9 + 1(表字符串结尾) 共19个字节。下次再进行字符串拼接时，如果要拼接的字符串长度小于free(9)则不会进行扩容，这就是sds的空间预分配。那么问题来了，如果对sds进行字符串进行截掉操作呢？ ​ 还是这个sds，我们删除最后6个字节“ redis”**（注意空格)**，此时它将变为： ​ 显然内存空间并没有被回收，空余的空间会记录在free里。你也不用担心一个巨大的free值出现，因为sds也提供了手动消除free的api，让我们在真正需要的时候进行操作。这就是sds的惰性空间释放 ​ 惰性空间释放和空间预分配本质上都是为了降低redis的内存分配次数，提高整体性能。 4、二进制安全： ​ 我们知道普通的c字符串是以’\\0’结尾的，那么图片、视频、音乐、压缩包等格式的文件的二进制编码难免会出现’\\0’。c字符串在读取一个文件的二进制时，碰到’\\0’就不会往下读了，所以说c串不是二进制安全的。sds本身就是以len的长度来判断字符串的结束，而不是’\\0’，所以可以用来存储二进制值。 jemalloc ​ 无论是上述的哪种结构对象(dicEntry、redisObject、SDS)在分配内存时，都需要内存分配器为它们分配内存，而jemalloc是redis的默认内存分配器。了解jemalloc需要先对内存碎片有个大概的理解。举个例子： ​ redis做删除值的时候，内存并没有直接被系统回收利用，这部分的内存就叫做内存碎片。对内存碎片有兴趣可以看看这里。jemalloc作为redis默认的内存分配器，在控制内存碎片这块做的相对较好。下图是jemalloc的内存分配策略： 例如一个对象占13个字节，jemalloc将会为它分配16哥字节的内存空间。 2.2 对外数据类型​ 5种基本数据类型其实就是redis的对外的表现，但其实每种基本数据类型在redis至少对应两种内部编码，且不同的基本数据类型可能对应同一个内部编码，对应关系如下图所示： ​ 可以看到hashtable和ziplist都被多种数据类型所使用，关于每种基本数据类型的指令可以在这里看到，我在这里主要介绍一下每种数据类型对应的内部编码。其中通过object encoding可以查看对应的内部编码。 Strings​ int: 当value值是整数(包括负数)时，采用int编码。且它只占用8个字节，超过这个长度则转为embstr 12345678127.0.0.1:6379&gt;set key 12345&quot;OK&quot;127.0.0.1:6379&gt;object encoding key&quot;int&quot;127.0.0.1:6379&gt;set key -1&quot;OK&quot;127.0.0.1:6379&gt;object encoding key&quot;int&quot; ​ embstr:用于存储小于等于39个字节的字符串，这个39其实是这么来的：Strings的存储其实是放在redisObject和sds中的，redisObject占用16字节的空间，sds占据9(len:4,free:4结尾:1)字节+buf（实际字符串长度）的空间，当buf恰好等于64-9-16=39 时，根据jemalloc 的内存分配策略，会正好分配64个字节的内存空间。 ​ raw: 那么raw就是用于存储大于39字节的字符串了。且由于embstr是只读的，对于embstr实现的字符串做编辑操作后，其内部实现都会采用raw(不管修改后是否大于39个字节) 12345678910127.0.0.1:6379&gt;set blog gzldc&quot;OK&quot;127.0.0.1:6379&gt;object encoding blog&quot;embstr&quot;127.0.0.1:6379&gt;append blog .github.io&quot;15&quot;127.0.0.1:6379&gt;object encoding blog&quot;raw&quot;127.0.0.1:6379&gt;strlen blog&quot;15&quot; hash​ 哈希不仅是redis的基本数据类型之一，也是redis本身作为键值对数据库所使用的数据结构。用人话说就是hash本身也是key-value结构，当存储一个hash键时，在redis中的存储大致是这样的： ​ ziplist(压缩表):当存储的值满足以下两个条件时，hash会采用压缩表作为内部实现。 1、存储的value元素数量小于redis.conf中hash-max-ziplist-entries的值(默认512) ​ note 虽然压缩表的增删改的时间复杂度都是O(n),但是因为它里面存储的数据量较小，所以时间也在可接受范围。 123456789101112&gt;hset hash1 k1 v1&quot;1&quot;&gt;object encoding hash1&quot;ziplist&quot;&gt;hset hash2 k2 v222222222222222222222222222222&quot;1&quot;&gt;object encoding hash2&quot;ziplist&quot;导演库:0&gt;hset hash2 k2 v22222222222222222222222222222222222222222222222222222222222222222222222222222&quot;1&quot;导演库:0&gt;object encoding hash2&quot;hashtable&quot; ​ 下图是redis.cfg文件中关于这两个参数的设置： ​ hashtable(哈希表): 增删改的时间复杂度为O(1),所以当hash里存储较大数据时，默认编码采取哈希表。 list(列表)​ list是用链表实现的，这也意味着list的头尾操作的时间复杂度都是O(1),查找的复杂度为O(n),最大容量为2^32-1。在后面我们会用redis实现一个消息队列，用的也是列表。 ​ linkedlist(双端链表):如下图所示，其中value用于存储值，prev指向前一个节点(实际为type为字符串的redisObject)，next指向后一个节点。只使用listnode便可以简单的实现一个双向链表。 只使用listnode便可以简单的实现一个双向链表，但是使用list+listnode会降低获取链表长度、总数的复杂度，实现如下： ​ head:指向链表的表头 ​ tail:指向链表的结尾 len:用于记录链表节点的数量 dup、free、match是节点操作函数，在实现多态链表中会有涉及。 当列表类型无法满足ziplist的条件时（存储的数量&gt;512或者元素值&lt;64），Redis会使用linkedlist作为列表的内部实现。 set​ 集合(set)和列表都可以用于存储多字符串，且set是无序的。这意味着插入的复杂度为O(1),查找的复杂度为O(n),且set的元素不能重复。另外redis除了提供常规的curd外，还提供取集合的并集、差集、合集。 ​ 内部编码为intset(整数集合)和hashtable（哈希表）。 intset:当set中存储的数据都为整数且数量小于redis.conf中set-max-intset-entries(默认512)时，采取inset编码。 hashtable:intset无法满足存储要求时将会转位哈希表存储。 zset​ zset为有序集合(sorted set)，因redis中关于sorted set的命令以z开头，所以又称zset. zset的有序和list的有序有所不同，list中是依靠数组的索引下标实现的，zset是为每一个元素设置了score来实现有序的。 ​ 内部编码中的ziplist(压缩表)和hashtable(哈希表)上文有简述，这里主要介绍一下skiplist(跳跃表)。跳跃表除了用于实现zset外还是redis集群的内部数据结构 ​ 跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的 ​ -《redis的设计与实现》 跳跃表由skiplistNode和skiplist 两个结构体组成，他们的构成如下： 1234567891011121314151617181920212223242526//skiplistNodetypedef struct zskiplistNode &#123; //成员对象 robj *obj; //分值 double score; //后退指针 struct zskiplistNode *backward; //层 struct zskiplistLevel &#123; //前进指针 struct zskiplistNode *forward; //跨度 unsigned int span; &#125; level[];&#125; zskiplistNode;//zskiplisttypedef struct zskiplist &#123; //header指向表头 tail指向表尾 struct zskiplistNode *header, *tail; //所有节点的数量（包含首节点） unsigned long length; //最高层数（不包含首节点） int level;&#125; zskiplist; 关于跳跃表的实现需要画更多的图利于理解，也算是为自己新开了个坑。后面会用单独的一篇文章来描述跳表。 3 总结​ redis的数据存储及内部编码是redis入门的基础，在后续的文章将要分享的网络模型、持久化、哨兵集群、分布式消息/队列也离不开redis的数据存储。 ​ 我是罐子里的茶，希望保持持续分享的能力。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}],"author":"罐子里的茶"},{"title":"Wireshark浅析TCP三次握手","slug":"三次握手","date":"2021-12-21T15:51:51.000Z","updated":"2022-03-21T10:36:27.689Z","comments":true,"path":"2021/12/21/三次握手/","link":"","permalink":"http://example.com/2021/12/21/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/","excerpt":"","text":"简述我不想一开始直接搬网络描述图来讲三次握手亦或试图用大量专业词汇让你熟悉它，而是想用简单的描述，让大家对三次握手有个大概的印象。用Wireshark抓包工具分析TCP报文中大家比较关注的syn(Synchronize Sequence Numbers 同步序列号)和ack(ACKnowledge Character 确认字符)。 如果你不能简单的解释它，说明你还没有足够理解它 –爱因斯坦 1 什么是TCP三次握手字面意思就是三次交互，也是三次 「TCP数据包」 的传输。交互的目的是建立连接，让通信双方确认 「对方」 能够接收到自己发送的消息。 下图简单描述了三次握手的过程： 有同学问我为什么要回复x+1，这就是协议的魅力所在了。协议本质上就是一种约定，设计tcp的那群大佬们完全可以设计为x+2，这不应该是我们纠结的点。 2 为什么要三次握手tcp是传输层协议，握手的目的是 建立连接 。事实上四次，甚至更多次的握手更能保证通信的建立，但无疑也会增加网络开销。 「三次」 是一个能够保证双方建立连接的最小通讯数。 3 TCP报文构成下图为Tcp的报文构成，因本文主要讲述三次握手，侧重点也主要放在序列号和确认应答号上，对TCP的报文感兴趣的可以看看思否的这篇文章。下面结合Wireshark，对应这张图浅析一下三次握手。 三次握手也就是三次TCP的报文传输，这里可以注意到序列号和确认应答号都是32位。所以这也解释了ACK和SYN的取值范围是 0 - 2^32 -1 即4,294,967,295。 4 使用Wireshark浅析三次握手中的报文简单介绍一下wireshark，它是一款优秀的抓包工具。可以抓取经过我们电脑网卡上的网络信息，当然也包括我们今天要抓取的TCP数据包。 以打开百度为例，首先需要确认百度的ip，可以通过ping命令获取： 12345shishuai@iMac ~ % ping www.baidu.comPING www.a.shifen.com (180.101.49.12): 56 data bytes64 bytes from 180.101.49.12: icmp_seq=0 ttl=52 time=11.738 ms64 bytes from 180.101.49.12: icmp_seq=1 ttl=52 time=12.248 ms64 bytes from 180.101.49.12: icmp_seq=2 ttl=52 time=11.474 ms 注意这里使用www.baidu.com而不是baidu.com。记录下反馈的ip地址：180.101.49.12。这个ip因人而异，每个地区会有所不同。 打开wireshark界面： 【ps：建议打开前先退出浏览器。】 左侧对应你的电脑网卡，如果你不知道选择哪个，可以注意右侧的折线图，有波动的就是你在使用的网卡。 因为我们的电脑的网络流量是实时在变的，所以需要在这里过滤出来自www.baidu.com 的流量信息。 对应的过滤规则为： 1ip.addr == 180.101.49.12 &amp;&amp; tcp 注意这里的ip为上一步通过ping命令获取的ip。 输入后，回车。可以看到下面还是空的流量信息。现在再打开百度首页，关注这里的流量信息,可以发现三次握手的流量包信息已经显示在下方了： 我们双击第一条报文，查看详情： wireshark中显示报文格式为16(2^4)进制，即每个字符对应4位，一共8个字符一共占用4 * 8 = 32位。和可以看TCP报文中syn序列号长度是一致的。16进制下的:e2026015即对应十进制的:3791806485。 当然我们也可以查看原始的2进制数据包，32位的长度也会更加直接。只需要在下方空白处右击，选择:‘… as bits 即可。 接下来我们点击第二次数据包，即第二次握手，也是百度服务器对我们的回复包： 可以看到百度回执ack确实为我们第一次握手中的syn+1(3791806485 + 1)。另外自身生成的seq序列为：1559326373，也对应文章一开始放的小红和小蓝的对话图中的第七步： 这里ack即对应响应ACK(y)值，seq对应服务器返回的x值。 接下来看第三次响应，也是客服端对百度的回执包信息： 可以看到最后的一次握手中，ack值为第二次握手回执的syn值+1。seq序列为二次握手中服务器回执的ack确认序列号。至此三次握手完成，连接建立完毕，可以开始进行数据的传输。 5 总结分析数据包虽然是个比较耗时的事情但确实可以加深我们的印象，也可以让抽象的描述具体化。 另外多说一句，虽然分析的过程比较久但tcp的建立时间是非常快的，我们在打开一个网站的瞬间就建立好了。四次挥手同理，有兴趣的话你可以试试用wireshark抓取4次挥手的数据包看看，希望大家共同进步。","categories":[{"name":"协议","slug":"协议","permalink":"http://example.com/categories/%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"协议","slug":"协议","permalink":"http://example.com/tags/%E5%8D%8F%E8%AE%AE/"}],"author":"罐子里的茶"},{"title":"「java中的数据结构和算法」(1):概述","slug":"「懂一点数据结构」-1-概述","date":"2021-12-06T03:46:25.000Z","updated":"2022-03-30T07:00:22.736Z","comments":true,"path":"2021/12/06/「懂一点数据结构」-1-概述/","link":"","permalink":"http://example.com/2021/12/06/%E3%80%8C%E6%87%82%E4%B8%80%E7%82%B9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8D-1-%E6%A6%82%E8%BF%B0/","excerpt":"","text":"简述数据结构(data structure)本身是不区分语言的，例如数组在java、c++、js等语言中均有不同的实现。大学也将数据结构做为一门单独的课程，数据结构的重要性不言而喻。举个例子，现在需要记录公司员工的工号和名字，你是选择数组、链表、集合、HashMap或者其它?尽管任意容器都可以用于存储，但考虑到数据的查询、编辑、排序等操作，一个优秀的程序员会选择最合适的数据结构。 数据结构是一门和计算机硬件与软件都相关的学科，其中包含算法(algorithm)、数据存储架构、排序、查找、程序设计的概念和哈希数。 ​ –《图解数据结构-使用java》 1.常见的数据结构java中常见的数据结构如图： 如果你还不太了解时间复杂度的概念，推荐你花5分钟看看这个,下表为整理后的各数据结构的优缺点。 数据结构 时间复杂度 优点 缺点 数组(Array) 访问O(1)、查找O(n) 查询快，如果知道索引，时间复杂度仅为常数项 删除慢、无法扩容 链表(LinkedList) 查询、添加、删除均为O(n) 插入、删除快（平衡二叉树） 查询慢 树(二叉搜索树) 查询、添加、删除均为O(log n) 【最坏情况O(n】 查找，插入，删除都快 实现复杂 树(红黑树) 查询、添加、删除均为O(log n)【最坏情况O(n】 查找，插入，删除都快 实现复杂 堆(priorityQueue) 添加、删除 最大/最小:O(log n)，查询最大/最小值:O(1)，查找/删除 其他值:O(n) 插入，删除快，对最大数据的项存取很快 对其他数据项存取很慢 队列(queue、circular queue) 查询、添加、删除均为O(1) 提供先进先出的存取方式 存取其他项都很慢 哈希表(hashMap、hashTable) 查询、添加、删除：O(1)，扩容:O(n) 如果关键字已知则存取速度极快，插入快 删除慢，如果不知道关键字则存取很慢，对存储空间使用不充分 现在看得一知半解没有关系，只是让大家有个基础概念。后面的文章会逐个抽丝剥茧，感受数据结构的魅力。 2.算法算法这两个字距离普通的开发人员似乎有点高端，举几个生活中常见的例子： 短视频推荐 b站、抖音、快手等一系列短视频之所以能够让用户保持不停刷下一个视频的动力，离不开背后强大算法的支撑。包括但不限于用户年龄、性别、地域，其实在算法工程师眼里都是运算所需的输入元素。 淘宝推荐 每一个淘宝的猜你喜欢同样离不开阿里强的的算法支持。购物历史、浏览记录、商品浏览时常、评价等数据都会是阿里工程师计算你看到的猜你喜欢界面的输入元素。 还有我们java程序员常用的HashMap内部实现就涉及一系列复杂的算法。一个优秀的算法对使用者而言是无感的，但又面面俱到。我想这可能也是HashMap如此经典的原因之一。 数据结构与算法是程序设计实践中最基本的内涵。程序能否快速而有效的完成预定的任务，取决于是否选对了数据结构，而程序能否清楚而正确的把问题解决，则取决于算法。 2.1 算法的5个特征 《图解数据结构：使用java》 2.2 算法的设计原则 正确性 正确性是一个算法的基。举个栗子：我是一个程序员(男)，刷b站时每次都给我推荐口红怎么涂才好看，时间一久我自然就不会再打开它。 可读性 算法的实现离不开代码，优秀的算法实现思路总是清晰明了、逻辑清楚。其次良好的编码习惯也易于编辑调整、更新迭代。 健壮性 用户不是总能按照程序员给定的输入条件进行输入的，我们必须考虑到不同的输入(input)元素，这里的输入也是算法的特征之一。一句话健壮性就是考虑运算中的种种可能性，针对每一个分支给出合适的解，保证算法总是有输出的。 速度快 还是这个栗子：刷b站时，系统提示：稍等，正在计算你喜欢的下一个视频，用户体验直接0分。算法可能并不都快，但是速度快一定是优秀算法的特征之一。 低存储 我们常用的redis每个数据类型都考虑到内存的占用，尽可能榨干计算的每一个byte(字节)。对redis的数据存储有兴趣的同学可以看看这里。 3.总结​ 这里只是让大家对数据结构和算法有一个初步的印象，具体的实现会分篇详细描述。 这里是我的博客，正在更新redis及java中的数据结构和算法系列内容，欢迎你来共同分享。","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"author":"罐子里的茶"}],"categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"},{"name":"协议","slug":"协议","permalink":"http://example.com/categories/%E5%8D%8F%E8%AE%AE/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"},{"name":"协议","slug":"协议","permalink":"http://example.com/tags/%E5%8D%8F%E8%AE%AE/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]}